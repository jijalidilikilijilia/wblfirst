# Задание L1 для стажировки Wildberries 
## Устные вопросы

### 1. Какой самый эффективный способ конкатенации строк?
Ответ: Если заранее известно, что объединять, то str := strings.Join([]string{"раз", "два", "три"}, "")
Если количество строк неизвестно - использовать strings.Builder и функцию WriteString().

### 2. Что такое интерфейсы, как они применяются в Go?
Ответ: В Go интерфейсы представляют собой набор методов, которые должны быть 
реализованы другими типами данных. Они определяют некий контракт для типов, 
гарантируя наличие реализаций определенных методов. 

### 3. Чем отличаются RWMutex от Mutex?
Ответ: Основное отличие заключается в том, что при использовании RWMutex несколько потоков могут читать данные параллельно, но только один поток может записывать данные в конкретный момент времени, когда обычный Mutex полностью блокирует и на запись и на чтение.

### 4. Чем отличаются буферизированные и не буферизированные каналы?
Ответ: Буферизированный канал имеет фиксированную емкость и может принимать данные только до тех пор, 
пока он не заполнен. Небуферизированный канал не имеет емкости и блокирует отправителя, 
пока нет приемника. В небуферизированном канале данные передаются синхронно, а в буферизированном - асинхронно.

### 5. Какой размер у структуры struct{}{}?
Ответ: 0 байт, т.к. это структура без полей.

### 6. Есть ли в Go перегрузка методов или операторов?
Ответ: Нет. Методы определяются по имени и типу получателя (receiver type). Два метода
с одинаковыми именами, но разными типами получателей, считаются разными методами.

### 7. В какой последовательности будут выведены элементы map[int]int?
Пример:
m[0]=1
m[1]=124
m[2]=281

Ответ: При использовании цикла for := range вывод данных из мапы всегда будет случайным.
При выводе через fmt.Print порядок соблюдается.

### 8. В чем разница make и new?
Ответ: make используется для создания слайсов, карт (map) и каналов, 
и возвращает инициализированное значение указанного типа. new используется 
для выделения памяти для указанного типа и возвращает указатель на эту память, но при этом 
не ицинициализирует её 

### 9. Сколько существует способов задать переменную типа slice или map?
Ответ: 
slice: Явно, через литералы. Используя make или new. Так же слайс можно получить через срез другого массива. 
map: Литералы, make или new 

### 10. Что выведет данная программа и почему?
```
    func update(p *int) {
        b := 2
        p = &b
    }

    func main() {
        var (
            a = 1
            p = &a
        )

        fmt.Println(*p)
        update(p)
        fmt.Println(*p)
    }
```
Ответ: 1 1. Вначале выводится разыменованный указатель на переменную a = 1, затем в функцию update указатель передаётся по значению (копируется) и изменения внутри update() не отражаются на оригинале, поэтому второй раз тоже выводится 1.

### 11. Что выведет данная программа и почему?
```
    func main() {
        wg := sync.WaitGroup{}
        for i := 0; i < 5; i++ {
            wg.Add(1)
            go func(wg sync.WaitGroup, i int) {
                fmt.Println(i)
                wg.Done()
            }(wg, i)
        }
        wg.Wait()
        fmt.Println("exit")
    }
```

Ответ: числа от 0 до 4 в случайном порядке, затем вызовется deadlock, т.к. передача wg 
в горутины осуществляется не по ссылке и копируется для каждой функцию и не влияет на
исходый wg, тем самым мы блокируемся на wg.Wait(). Ведь счётчик никогда не изменится с 5 на 0 

### 12. Что выведет данная программа и почему?
```
    func main() {
        n := 0
        if true {
            n := 1
            n++
        }
        fmt.Println(n)
    }
```
Ответ: 0. Внутри блока if создаётся совершенно другая, локальная переменная с тем же 
названием, которая уничтожается после выхода из блока. Затем выводится оригинал, то есть 0 

### 13. Что выведет данная программа и почему?
```
    func someAction(v []int8, b int8) {
        v[0] = 100
        v = append(v, b)
    }

    func main() {
        var a = []int8{1, 2, 3, 4, 5}
        someAction(a, 6)
        fmt.Println(a)
    }
```
Ответ: 100 2 3 4 5
Результат такой, потому что изменения элемента слайса влияет на исходный слайс, т.к. 
копия указателя всё равно указывает на старую оригинал. Однако изменения через append влияет только
в контексте той функции, в которой вызывается. Но не влияет на оригинал   

### 14. Что выведет данная программа и почему?
```
    func main() {
        slice := []string{"a", "a"}
        func(slice []string) {
            slice = append(slice, "a")
            slice[0] = "b"
            slice[1] = "b"
            fmt.Print(slice)
        }(slice)
        fmt.Print(slice)
    }
```
Ответ: [b b a][a a]
Внутри анонимной функции мы переаллоцируем слайс и работаем уже с другим. У другого слайса 
меняем первые 2 элемента и теперь он выглядит как [b b a]. Но т.к. оригинал никак не был затронут, 
то в конце выводится [a a]